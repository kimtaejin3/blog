1:HL["/_next/static/media/a34f9d1faa5f3315-s.p.woff2","font",{"crossOrigin":"","type":"font/woff2"}]
2:HL["/_next/static/css/858649a920aaaab7.css","style",{"crossOrigin":""}]
0:["cNCkURMXIkarp8nt0Bu_d",[[["",{"children":["post",{"children":[["slug","react-key","d"],{"children":["__PAGE__?{\"slug\":\"react-key\"}",{}]}]}]},"$undefined","$undefined",true],"$L3",[[["$","link","0",{"rel":"stylesheet","href":"/_next/static/css/858649a920aaaab7.css","precedence":"next","crossOrigin":""}]],"$L4"]]]]
5:HL["/_next/static/css/017c43e30ed32e62.css","style",{"crossOrigin":""}]
6:I[688,["185","static/chunks/app/layout-cb7e5c7c8f1c9c28.js"],"ThemeProvider"]
7:I[6954,[],""]
8:I[7264,[],""]
4:[["$","meta","0",{"charSet":"utf-8"}],["$","title","1",{"children":"React Key"}],["$","meta","2",{"name":"description","content":"개발 및 일상 기록 개인 블로그"}],["$","meta","3",{"name":"viewport","content":"width=device-width, initial-scale=1"}],["$","meta","4",{"name":"next-size-adjust"}]]
3:[null,["$","html",null,{"lang":"en","children":["$","body",null,{"className":"__className_d65c78","children":["$","div",null,{"className":"mx-auto max-w-3xl py-8 px-4","children":["$","$L6",null,{"attribute":"class","defaultTheme":"system","enableSystem":true,"disableTransitionOnChange":true,"children":["$","$L7",null,{"parallelRouterKey":"children","segmentPath":["children"],"loading":"$undefined","loadingStyles":"$undefined","hasLoading":false,"error":"$undefined","errorStyles":"$undefined","template":["$","$L8",null,{}],"templateStyles":"$undefined","notFound":[["$","title",null,{"children":"404: This page could not be found."}],["$","div",null,{"style":{"fontFamily":"system-ui,\"Segoe UI\",Roboto,Helvetica,Arial,sans-serif,\"Apple Color Emoji\",\"Segoe UI Emoji\"","height":"100vh","textAlign":"center","display":"flex","flexDirection":"column","alignItems":"center","justifyContent":"center"},"children":["$","div",null,{"children":[["$","style",null,{"dangerouslySetInnerHTML":{"__html":"body{color:#000;background:#fff;margin:0}.next-error-h1{border-right:1px solid rgba(0,0,0,.3)}@media (prefers-color-scheme:dark){body{color:#fff;background:#000}.next-error-h1{border-right:1px solid rgba(255,255,255,.3)}}"}}],["$","h1",null,{"className":"next-error-h1","style":{"display":"inline-block","margin":"0 20px 0 0","padding":"0 23px 0 0","fontSize":24,"fontWeight":500,"verticalAlign":"top","lineHeight":"49px"},"children":"404"}],["$","div",null,{"style":{"display":"inline-block"},"children":["$","h2",null,{"style":{"fontSize":14,"fontWeight":400,"lineHeight":"49px","margin":0},"children":"This page could not be found."}]}]]}]}]],"notFoundStyles":[],"childProp":{"current":["$","$L7",null,{"parallelRouterKey":"children","segmentPath":["children","post","children"],"loading":"$undefined","loadingStyles":"$undefined","hasLoading":false,"error":"$undefined","errorStyles":"$undefined","template":["$","$L8",null,{}],"templateStyles":"$undefined","notFound":"$undefined","notFoundStyles":"$undefined","childProp":{"current":["$","$L7",null,{"parallelRouterKey":"children","segmentPath":["children","post","children",["slug","react-key","d"],"children"],"loading":"$undefined","loadingStyles":"$undefined","hasLoading":false,"error":"$undefined","errorStyles":"$undefined","template":["$","$L8",null,{}],"templateStyles":"$undefined","notFound":"$undefined","notFoundStyles":"$undefined","childProp":{"current":["$L9",["$","article",null,{"className":"","children":[["$","div",null,{"className":"mb-16 text-center","children":[["$","time",null,{"dateTime":"2025-02-04T00:00:00.000Z","className":"mb-1 text-xs text-time","children":"February 4, 2025"}],["$","h1",null,{"className":"text-3xl font-bold","children":"React Key"}]]}],["$","div",null,{"className":"markdownStyles_markdown__31ce6","children":[["$","h2","h2-0",{"children":"리액트 Key props에 대해서"}],"\n",["$","p","p-0",{"children":"리액트에서 배열을 렌더링할 때 key props를 사용해야 합니다. 만약 key props를 사용하지 않으면 브라우저 콘솔창에 경고 메시지가 출력되고, 린트를 사용할 경우에도 경고 혹은 오류 메시지가 보여질 수 있습니다."}],"\n",["$","pre","pre-0",{"children":["$","code","code-0",{"className":"language-jsx","children":"return (\n  <>\n    {todos.map((todo) => (\n      <TodoItem todo={todo} /> // 🚫\n    ))}\n  </>\n);\n"}]}],"\n",["$","h3","h3-0",{"children":"브라우저 콘솔창 경고 메시지"}],"\n",["$","p","p-1",{"children":["$","img","img-0",{"src":"/images/image.png","alt":"브라우저 콘솔창 경고 메시지"}]}],"\n",["$","h3","h3-1",{"children":"린트 경고 메시지"}],"\n",["$","p","p-2",{"children":["$","img","img-0",{"src":"/images/image-1.png","alt":"린트 에러 메시지"}]}],"\n",["$","h2","h2-1",{"children":"리액트 Key props 사용 이유"}],"\n",["$","p","p-3",{"children":"그렇다면 리액트 key props 작성을 권장하는 이유가 무엇일까요?"}],"\n",["$","h3","h3-2",{"children":"최적화"}],"\n",["$","p","p-4",{"children":"리액트는 Virtual DOM을 통해 렌더링을 최적화하고, Reconciliation(재조정)과정을 통해 변경이 일어난 부분을 파악합니다. key props는 React가 각 요소를 고유하게 식별할 수 있게 해주어, 실제 DOM 업데이트 시 필요한 변경사항만 정확하게 반영할 수 있게 합니다."}],"\n",["$","h3","h3-3",{"children":"예시"}],"\n",["$","pre","pre-1",{"children":["$","code","code-0",{"className":"language-jsx","children":"const App = () => {\n  const [items, setItems] = useState([1, 2, 3]);\n\n  return (\n    <ul>\n      {items.map((item) => (\n        <li>{item}</li>\n      ))}\n    </ul>\n  );\n};\n"}]}],"\n",["$","p","p-5",{"children":"위 코드를 그림으로 나타내면 아래와 같습니다."}],"\n",["$","p","p-6",{"children":["$","img","img-0",{"src":"/images/image3.png","alt":"리액트 컴포넌트 렌더링"}]}],"\n",["$","p","p-7",{"children":"위 컴포넌트가 리렌더링 된다면 재조정 과정에서 각각의 li들이 바뀌었는지 확인하는 과정을 거칠 것입니다."}],"\n",["$","p","p-8",{"children":["$","img","img-0",{"src":"/images/image4.png","alt":"리액트 컴포넌트 렌더링"}]}],"\n",["$","p","p-9",{"children":"변경사항이 없다면 실제 DOM에 반영시키지 않을 것입니다."}],"\n",["$","p","p-10",{"children":"만약 items에 4라는 요소가 배열의 마지막에 추가 된다면 어떨까요?"}],"\n",["$","p","p-11",{"children":["$","img","img-0",{"src":"/images/image5.png","alt":"리액트 컴포넌트 렌더링"}]}],"\n",["$","p","p-12",{"children":"새로 추가된 4라는 item은 재조정 과정을 거쳐 실제 DOM에 반영될 것입니다. 그외에 1, 2, 3은 변경사항이 없기 때문에 실제 DOM에 반영되지 않을 것입니다."}],"\n",["$","p","p-13",{"children":"하지만 4가 배열의 처음에 추가된다면 어떨까요?"}],"\n",["$","p","p-14",{"children":["$","img","img-0",{"src":"/images/image6.png","alt":"리액트 컴포넌트 렌더링"}]}],"\n",["$","p","p-15",{"children":"위와 같이 재조정 과정에서 두 Virtual Dom을 비교할 때 React는 item3은 새로 추가되었다고 생각하고 그 외는 모두 변경되었다고 생각합니다. 실제로 item 1, 2, 3은 변경사항이 없음에도 실제 DOM에 새롭게 적용되게 됩니다."}],"\n",["$","p","p-16",{"children":"지금까지 key props를 사용하지 않았을 때의 문제점을 알아봤습니다. 이제 key props를 사용해서 문제점을 해결해봅시다."}],"\n",["$","pre","pre-2",{"children":["$","code","code-0",{"className":"language-jsx","children":"const App = () => {\n  const [items, setItems] = useState([1, 2, 3]);\n\n  return (\n    <ul>\n      {items.map((item) => (\n        <li key={item}>{item}</li>\n      ))}\n    </ul>\n  );\n};\n"}]}],"\n",["$","p","p-17",{"children":"위와 같이 key props를 사용하면 아래와 같은 효과를 얻을 수 있습니다."}],"\n",["$","p","p-18",{"children":["$","img","img-0",{"src":"/images/image7.png","alt":"리액트 컴포넌트 렌더링"}]}],"\n",["$","p","p-19",{"children":"고유한 key값을 통해 어떤 값이 추가되었고 어떤 값이 변경이 없는지 정확히 파악할 수 있습니다. 따라서 적은 비용으로 최소한의 변경만 실제 DOM에 반영하고 연산작업을 하여 최적화를 할 수 있습니다."}],"\n",["$","h2","h2-2",{"children":"Key props로 배열의 index를 사용하면 안되는 이유"}],"\n",["$","p","p-20",{"children":"key props를 추가한다면 재조정 과정에서 최적화가 되어 좋을 것입니다. 그렇다면 key로는 아무값이나 넣어도 괜찮을까요? key값은 고유한게 좋으며 바뀌는 값으로 하는 것은 좋지 않습니다. 보통 배열의 index를 key로 사용하는 코드를 볼 수 있는데 리스트 요소가 바뀌지 않는다면 상관없지만 리스트 요소가 바뀐다면 문제가 발생할 수 있습니다."}],"\n",["$","pre","pre-3",{"children":["$","code","code-0",{"className":"language-jsx","children":"const App = () => {\n  const [items, setItems] = useState([1, 2, 3]);\n\n  return (\n    <ul>\n      {items.map((item, index) => (\n        <li key={index}>{item}</li>\n      ))}\n    </ul>\n  );\n};\n"}]}],"\n",["$","p","p-21",{"children":"위와 같이 코드에서 item 4가 items 배열에 맨 앞에 추가된다면 어떨까요?"}],"\n",["$","p","p-22",{"children":[["$","img","img-0",{"src":"/images/image8.png","alt":"리액트 컴포넌트 렌더링"}],"\n일단 알아두셔야 할 것은 key이 같으면 인스턴트는 재사용이 된다는 것입니다. 위의 상황에서\nkey 값이 같은 것들끼리 1:1비교를 합니다. key값이 0인 컴포넌트는 재사용되면서 text가 item4로 변경되고, key 값이 각각 1과 2인 컴포넌트들도 재사용되면서 각각 item1, item2로 텍스트가 변경됩니다. key값이 3인 item은 새롭게 추가됐다고 판단합니다."]}],"\n",["$","p","p-23",{"children":"여기서 중요한 문제점이 발생할 수 있습니다. 예를 들어, key값이 0인 컴포넌트가 단순히 텍스트만 렌더링 하는게 아니라 내부 상태(state)를 가지고 있다면, 그 상태는 컴포넌트가 재사용되면서 그대로 유지됩니다. 즉, item1의 상태가 item4에게 그대로 이어지게 되는 것입니다. 이는 사용자 입장에서 예상치 못한 동작을 발생시킬 수 있습니다."}],"\n",["$","h3","h3-4",{"children":"예제"}],"\n",["$","pre","pre-4",{"children":["$","code","code-0",{"className":"language-jsx","children":"function App() {\n  const [todos, setTodos] =\n    useState<{ id: number; text: string }[]>(todoListDefault);\n\n  return (\n    <>\n      {todos.map((todo, index) => (\n        <TodoItem key={index} todo={todo} onSetTodos={setTodos} />\n      ))}\n    </>\n  );\n}\n\nfunction TodoItem({\n  todo,\n  onSetTodos,\n}: {\n  todo: { id: number; text: string };\n  onSetTodos: Dispatch<SetStateAction<{ id: number; text: string }[]>>;\n}) {\n  const [isEditing, setIsEditing] = useState(false);\n  const [inputText, setInputText] = useState(todo.text);\n\n  return (\n    <div>\n      {isEditing ? (\n        <input\n          type=\"text\"\n          value={inputText}\n          onChange={(e) => setInputText(e.target.value)}\n        />\n      ) : (\n        <span>{todo.text}</span>\n      )}\n      <button\n        onClick={() => {\n          setIsEditing(!isEditing);\n          onSetTodos((prev) => [...prev, { id: 6, text: inputText }]);\n        }}\n      >\n        {isEditing ? \"저장\" : \"수정\"}\n      </button>\n    </div>\n  );\n}\n"}]}],"\n",["$","p","p-24",{"children":"위 코드에 대한 결과물은 아래와 같습니다. 맨 앞에 todo6 추가란 버튼을 누르면 todos 배열 맨 앞에 todo6 텍스트를 가진 todo를 추가하도록 했습니다."}],"\n",["$","p","p-25",{"children":["$","img","img-0",{"src":"/images/image9.png","alt":"리액트 컴포넌트 렌더링"}]}],"\n",["$","p","p-26",{"children":"수정 버튼을 누른 후의 결과물은 아래와 같습니다."}],"\n",["$","p","p-27",{"children":["$","img","img-0",{"src":"/images/image10.png","alt":"리액트 컴포넌트 렌더링"}]}],"\n",["$","p","p-28",{"children":"만약 위의 상태에서 맨 앞에 todo6 추가란 버튼을 누른다면 어떨까요?"}],"\n",["$","p","p-29",{"children":["$","img","img-0",{"src":"/images/image11.png","alt":"리액트 컴포넌트 렌더링"}]}],"\n",["$","p","p-30",{"children":"위와같이 todo1이 아닌 todo6가 수정 모드가 되었고 안에 텍스트 또한 todo1로 보입니다. 반면 기존 todo1은 수정모드 였다가 수정 모드가 해제 되었습니다. 이러한 문제는 key값을 고유한 값이 아닌 바뀔 수 있는 배열의 index로 사용했기 때문에 나타나는 문제입니다. 이를 해결해주려면 고유의 key값을 사용해야 합니다."}],"\n",["$","h2","h2-3",{"children":"마무리"}],"\n",["$","p","p-31",{"children":"리액트에서 key props를 사용하는 것은 단순히 경고 메시지를 없애기 위한 것이 아닙니다. key props는 리액트의 재조정 과정에서 중요한 역할을 하며, 애플리케이션의 성능 최적화와 올바른 동작을 위해 필수적입니다."}],"\n",["$","p","p-32",{"children":"key props 사용 시 주의할 점을 정리하면 다음과 같습니다:"}],"\n",["$","ol","ol-0",{"children":["\n",["$","li","li-0",{"children":"배열을 렌더링할 때는 반드시 고유한 key props를 사용해야 합니다."}],"\n",["$","li","li-1",{"children":"key값으로는 변경되지 않는 고유한 값(ID 등)을 사용해야 합니다."}],"\n",["$","li","li-2",{"children":"배열의 index를 key로 사용하면 예상치 못한 버그가 발생할 수 있으므로 피해야 합니다."}],"\n"]}]]}]]}],null],"segment":"__PAGE__?{\"slug\":\"react-key\"}"},"styles":[["$","link","0",{"rel":"stylesheet","href":"/_next/static/css/017c43e30ed32e62.css","precedence":"next","crossOrigin":""}]]}],"segment":["slug","react-key","d"]},"styles":[]}],"segment":"post"},"styles":[]}]}]}]}]}],null]
9:null
