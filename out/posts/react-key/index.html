<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="preload" href="/_next/static/media/a34f9d1faa5f3315-s.p.woff2" as="font" crossorigin="" type="font/woff2"/><link rel="preload" as="image" href="/images/image.png"/><link rel="preload" as="image" href="/images/image-1.png"/><link rel="preload" as="image" href="/images/image3.png"/><link rel="preload" as="image" href="/images/image4.png"/><link rel="preload" as="image" href="/images/image5.png"/><link rel="preload" as="image" href="/images/image6.png"/><link rel="preload" as="image" href="/images/image7.png"/><link rel="preload" as="image" href="/images/image8.png"/><link rel="preload" as="image" href="/images/image9.png"/><link rel="preload" as="image" href="/images/image10.png"/><link rel="stylesheet" href="/_next/static/css/858649a920aaaab7.css" crossorigin="" data-precedence="next"/><link rel="stylesheet" href="/_next/static/css/ee01f9582af6f7e6.css" crossorigin="" data-precedence="next"/><link rel="preload" as="script" fetchPriority="low" href="/_next/static/chunks/webpack-86e32af6ac68f24d.js" crossorigin=""/><script src="/_next/static/chunks/fd9d1056-9c59f76a84a7fd2a.js" async="" crossorigin=""></script><script src="/_next/static/chunks/472-7a03914a793ad443.js" async="" crossorigin=""></script><script src="/_next/static/chunks/main-app-302d44977a4871ab.js" async="" crossorigin=""></script><script src="/_next/static/chunks/app/layout-cb7e5c7c8f1c9c28.js" async=""></script><link rel="preload" as="image" href="/images/image11.png"/><title>React Key</title><meta name="description" content="개발 및 일상 기록 개인 블로그"/><meta name="next-size-adjust"/><script src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js" crossorigin="" noModule=""></script></head><body class="__className_d65c78"><div class="mx-auto max-w-3xl py-8 px-4"><script>((e,t,r,a,o,l,u,i)=>{let s=document.documentElement,c=["light","dark"];function p(t){(Array.isArray(e)?e:[e]).forEach(e=>{let r="class"===e,a=r&&l?o.map(e=>l[e]||e):o;r?(s.classList.remove(...a),s.classList.add(t)):s.setAttribute(e,t)}),i&&c.includes(t)&&(s.style.colorScheme=t)}if(a)p(a);else try{let e=localStorage.getItem(t)||r,a=u&&"system"===e?window.matchMedia("(prefers-color-scheme: dark)").matches?"dark":"light":e;p(a)}catch(e){}})("class","theme","system",null,["light","dark"],null,true,true)</script><article class=""><div class="mb-16 text-center"><time dateTime="2025-02-04T00:00:00.000Z" class="mb-1 text-xs text-time">February 4, 2025</time><h1 class="text-3xl font-bold">React Key</h1></div><div class="markdownStyles_markdown__IHKMg"><h2>리액트 Key props에 대해서</h2>
<p>리액트에서 배열을 렌더링할 때 key props를 사용해야 합니다. 만약 key props를 사용하지 않으면 브라우저 콘솔창에 경고 메시지가 출력되고, 린트를 사용할 경우에도 경고 혹은 오류 메시지가 보여질 수 있습니다.</p>
<pre><code class="language-jsx">return (
  &lt;&gt;
    {todos.map((todo) =&gt; (
      &lt;TodoItem todo={todo} /&gt; // 🚫
    ))}
  &lt;/&gt;
);
</code></pre>
<h3>브라우저 콘솔창 경고 메시지</h3>
<p><img src="/images/image.png" alt="브라우저 콘솔창 경고 메시지"/></p>
<h3>린트 경고 메시지</h3>
<p><img src="/images/image-1.png" alt="린트 에러 메시지"/></p>
<h2>리액트 Key props 사용 이유</h2>
<p>그렇다면 리액트 key props 작성을 권장하는 이유가 무엇일까요?</p>
<h3>최적화</h3>
<p>리액트는 Virtual DOM을 통해 렌더링을 최적화하고, Reconciliation(재조정)과정을 통해 변경이 일어난 부분을 파악합니다. key props는 React가 각 요소를 고유하게 식별할 수 있게 해주어, 실제 DOM 업데이트 시 필요한 변경사항만 정확하게 반영할 수 있게 합니다.</p>
<h3>예시</h3>
<pre><code class="language-jsx">const App = () =&gt; {
  const [items, setItems] = useState([1, 2, 3]);

  return (
    &lt;ul&gt;
      {items.map((item) =&gt; (
        &lt;li&gt;{item}&lt;/li&gt;
      ))}
    &lt;/ul&gt;
  );
};
</code></pre>
<p>위 코드를 그림으로 나타내면 아래와 같습니다.</p>
<p><img src="/images/image3.png" alt="리액트 컴포넌트 렌더링"/></p>
<p>위 컴포넌트가 리렌더링 된다면 재조정 과정에서 각각의 li들이 바뀌었는지 확인하는 과정을 거칠 것입니다.</p>
<p><img src="/images/image4.png" alt="리액트 컴포넌트 렌더링"/></p>
<p>변경사항이 없다면 실제 DOM에 반영시키지 않을 것입니다.</p>
<p>만약 items에 4라는 요소가 배열의 마지막에 추가 된다면 어떨까요?</p>
<p><img src="/images/image5.png" alt="리액트 컴포넌트 렌더링"/></p>
<p>새로 추가된 4라는 item은 재조정 과정을 거쳐 실제 DOM에 반영될 것입니다. 그외에 1, 2, 3은 변경사항이 없기 때문에 실제 DOM에 반영되지 않을 것입니다.</p>
<p>하지만 4가 배열의 처음에 추가된다면 어떨까요?</p>
<p><img src="/images/image6.png" alt="리액트 컴포넌트 렌더링"/></p>
<p>위와 같이 재조정 과정에서 두 Virtual Dom을 비교할 때 React는 item3은 새로 추가되었다고 생각하고 그 외는 모두 변경되었다고 생각합니다. 실제로 item 1, 2, 3은 변경사항이 없음에도 실제 DOM에 새롭게 적용되게 됩니다.</p>
<p>지금까지 key props를 사용하지 않았을 때의 문제점을 알아봤습니다. 이제 key props를 사용해서 문제점을 해결해봅시다.</p>
<pre><code class="language-jsx">const App = () =&gt; {
  const [items, setItems] = useState([1, 2, 3]);

  return (
    &lt;ul&gt;
      {items.map((item) =&gt; (
        &lt;li key={item}&gt;{item}&lt;/li&gt;
      ))}
    &lt;/ul&gt;
  );
};
</code></pre>
<p>위와 같이 key props를 사용하면 아래와 같은 효과를 얻을 수 있습니다.</p>
<p><img src="/images/image7.png" alt="리액트 컴포넌트 렌더링"/></p>
<p>고유한 key값을 통해 어떤 값이 추가되었고 어떤 값이 변경이 없는지 정확히 파악할 수 있습니다. 따라서 적은 비용으로 최소한의 변경만 실제 DOM에 반영하고 연산작업을 하여 최적화를 할 수 있습니다.</p>
<h2>Key props로 배열의 index를 사용하면 안되는 이유</h2>
<p>key props를 추가한다면 재조정 과정에서 최적화가 되어 좋을 것입니다. 그렇다면 key로는 아무값이나 넣어도 괜찮을까요? key값은 고유한게 좋으며 바뀌는 값으로 하는 것은 좋지 않습니다. 보통 배열의 index를 key로 사용하는 코드를 볼 수 있는데 리스트 요소가 바뀌지 않는다면 상관없지만 리스트 요소가 바뀐다면 문제가 발생할 수 있습니다.</p>
<pre><code class="language-jsx">const App = () =&gt; {
  const [items, setItems] = useState([1, 2, 3]);

  return (
    &lt;ul&gt;
      {items.map((item, index) =&gt; (
        &lt;li key={index}&gt;{item}&lt;/li&gt;
      ))}
    &lt;/ul&gt;
  );
};
</code></pre>
<p>위와 같이 코드에서 item 4가 items 배열에 맨 앞에 추가된다면 어떨까요?</p>
<p><img src="/images/image8.png" alt="리액트 컴포넌트 렌더링"/>
일단 알아두셔야 할 것은 key이 같으면 인스턴트는 재사용이 된다는 것입니다. 위의 상황에서
key 값이 같은 것들끼리 1:1비교를 합니다. key값이 0인 컴포넌트는 재사용되면서 text가 item4로 변경되고, key 값이 각각 1과 2인 컴포넌트들도 재사용되면서 각각 item1, item2로 텍스트가 변경됩니다. key값이 3인 item은 새롭게 추가됐다고 판단합니다.</p>
<p>여기서 중요한 문제점이 발생할 수 있습니다. 예를 들어, key값이 0인 컴포넌트가 단순히 텍스트만 렌더링 하는게 아니라 내부 상태(state)를 가지고 있다면, 그 상태는 컴포넌트가 재사용되면서 그대로 유지됩니다. 즉, item1의 상태가 item4에게 그대로 이어지게 되는 것입니다. 이는 사용자 입장에서 예상치 못한 동작을 발생시킬 수 있습니다.</p>
<h3>예제</h3>
<pre><code class="language-jsx">function App() {
  const [todos, setTodos] =
    useState&lt;{ id: number; text: string }[]&gt;(todoListDefault);

  return (
    &lt;&gt;
      {todos.map((todo, index) =&gt; (
        &lt;TodoItem key={index} todo={todo} onSetTodos={setTodos} /&gt;
      ))}
    &lt;/&gt;
  );
}

function TodoItem({
  todo,
  onSetTodos,
}: {
  todo: { id: number; text: string };
  onSetTodos: Dispatch&lt;SetStateAction&lt;{ id: number; text: string }[]&gt;&gt;;
}) {
  const [isEditing, setIsEditing] = useState(false);
  const [inputText, setInputText] = useState(todo.text);

  return (
    &lt;div&gt;
      {isEditing ? (
        &lt;input
          type=&quot;text&quot;
          value={inputText}
          onChange={(e) =&gt; setInputText(e.target.value)}
        /&gt;
      ) : (
        &lt;span&gt;{todo.text}&lt;/span&gt;
      )}
      &lt;button
        onClick={() =&gt; {
          setIsEditing(!isEditing);
          onSetTodos((prev) =&gt; [...prev, { id: 6, text: inputText }]);
        }}
      &gt;
        {isEditing ? &quot;저장&quot; : &quot;수정&quot;}
      &lt;/button&gt;
    &lt;/div&gt;
  );
}
</code></pre>
<p>위 코드에 대한 결과물은 아래와 같습니다. 맨 앞에 todo6 추가란 버튼을 누르면 todos 배열 맨 앞에 todo6 텍스트를 가진 todo를 추가하도록 했습니다.</p>
<p><img src="/images/image9.png" alt="리액트 컴포넌트 렌더링"/></p>
<p>수정 버튼을 누른 후의 결과물은 아래와 같습니다.</p>
<p><img src="/images/image10.png" alt="리액트 컴포넌트 렌더링"/></p>
<p>만약 위의 상태에서 맨 앞에 todo6 추가란 버튼을 누른다면 어떨까요?</p>
<p><img src="/images/image11.png" alt="리액트 컴포넌트 렌더링"/></p>
<p>위와같이 todo1이 아닌 todo6가 수정 모드가 되었고 안에 텍스트 또한 todo1로 보입니다. 반면 기존 todo1은 수정모드 였다가 수정 모드가 해제 되었습니다. 이러한 문제는 key값을 고유한 값이 아닌 바뀔 수 있는 배열의 index로 사용했기 때문에 나타나는 문제입니다. 이를 해결해주려면 고유의 key값을 사용해야 합니다.</p>
<h2>마무리</h2>
<p>리액트에서 key props를 사용하는 것은 단순히 경고 메시지를 없애기 위한 것이 아닙니다. key props는 리액트의 재조정 과정에서 중요한 역할을 하며, 애플리케이션의 성능 최적화와 올바른 동작을 위해 필수적입니다.</p>
<p>key props 사용 시 주의할 점을 정리하면 다음과 같습니다:</p>
<ol>
<li>배열을 렌더링할 때는 반드시 고유한 key props를 사용해야 합니다.</li>
<li>key값으로는 변경되지 않는 고유한 값(ID 등)을 사용해야 합니다.</li>
<li>배열의 index를 key로 사용하면 예상치 못한 버그가 발생할 수 있으므로 피해야 합니다.</li>
</ol></div></article></div><script src="/_next/static/chunks/webpack-86e32af6ac68f24d.js" crossorigin="" async=""></script><script>(self.__next_f=self.__next_f||[]).push([0]);self.__next_f.push([2,null])</script><script>self.__next_f.push([1,"1:HL[\"/_next/static/media/a34f9d1faa5f3315-s.p.woff2\",\"font\",{\"crossOrigin\":\"\",\"type\":\"font/woff2\"}]\n2:HL[\"/_next/static/css/858649a920aaaab7.css\",\"style\",{\"crossOrigin\":\"\"}]\n0:\"$L3\"\n"])</script><script>self.__next_f.push([1,"4:HL[\"/_next/static/css/ee01f9582af6f7e6.css\",\"style\",{\"crossOrigin\":\"\"}]\n"])</script><script>self.__next_f.push([1,"5:I[3728,[],\"\"]\n7:I[9928,[],\"\"]\n8:I[688,[\"185\",\"static/chunks/app/layout-cb7e5c7c8f1c9c28.js\"],\"ThemeProvider\"]\n9:I[6954,[],\"\"]\na:I[7264,[],\"\"]\n"])</script><script>self.__next_f.push([1,"3:[[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/858649a920aaaab7.css\",\"precedence\":\"next\",\"crossOrigin\":\"\"}]],[\"$\",\"$L5\",null,{\"buildId\":\"-oYuNDUt3nOOfTXNw1B4d\",\"assetPrefix\":\"\",\"initialCanonicalUrl\":\"/posts/react-key/\",\"initialTree\":[\"\",{\"children\":[\"posts\",{\"children\":[[\"slug\",\"react-key\",\"d\"],{\"children\":[\"__PAGE__?{\\\"slug\\\":\\\"react-key\\\"}\",{}]}]}]},\"$undefined\",\"$undefined\",true],\"initialHead\":[false,\"$L6\"],\"globalErrorComponent\":\"$7\",\"children\":[null,[\"$\",\"html\",null,{\"lang\":\"en\",\"children\":[\"$\",\"body\",null,{\"className\":\"__className_d65c78\",\"children\":[\"$\",\"div\",null,{\"className\":\"mx-auto max-w-3xl py-8 px-4\",\"children\":[\"$\",\"$L8\",null,{\"attribute\":\"class\",\"defaultTheme\":\"system\",\"enableSystem\":true,\"disableTransitionOnChange\":true,\"children\":[\"$\",\"$L9\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\"],\"loading\":\"$undefined\",\"loadingStyles\":\"$undefined\",\"hasLoading\":false,\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"template\":[\"$\",\"$La\",null,{}],\"templateStyles\":\"$undefined\",\"notFound\":[[\"$\",\"title\",null,{\"children\":\"404: This page could not be found.\"}],[\"$\",\"div\",null,{\"style\":{\"fontFamily\":\"system-ui,\\\"Segoe UI\\\",Roboto,Helvetica,Arial,sans-serif,\\\"Apple Color Emoji\\\",\\\"Segoe UI Emoji\\\"\",\"height\":\"100vh\",\"textAlign\":\"center\",\"display\":\"flex\",\"flexDirection\":\"column\",\"alignItems\":\"center\",\"justifyContent\":\"center\"},\"children\":[\"$\",\"div\",null,{\"children\":[[\"$\",\"style\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"body{color:#000;background:#fff;margin:0}.next-error-h1{border-right:1px solid rgba(0,0,0,.3)}@media (prefers-color-scheme:dark){body{color:#fff;background:#000}.next-error-h1{border-right:1px solid rgba(255,255,255,.3)}}\"}}],[\"$\",\"h1\",null,{\"className\":\"next-error-h1\",\"style\":{\"display\":\"inline-block\",\"margin\":\"0 20px 0 0\",\"padding\":\"0 23px 0 0\",\"fontSize\":24,\"fontWeight\":500,\"verticalAlign\":\"top\",\"lineHeight\":\"49px\"},\"children\":\"404\"}],[\"$\",\"div\",null,{\"style\":{\"display\":\"inline-block\"},\"children\":[\"$\",\"h2\",null,{\"style\":{\"fontSize\":14,\"fontWeight\":400,\"lineHeight\":\"49px\",\"margin\":0},\"children\":\"This page could not be found.\"}]}]]}]}]],\"notFoundStyles\":[],\"childProp\":{\"current\":[\"$\",\"$L9\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"posts\",\"children\"],\"loading\":\"$undefined\",\"loadingStyles\":\"$undefined\",\"hasLoading\":false,\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"template\":[\"$\",\"$La\",null,{}],\"templateStyles\":\"$undefined\",\"notFound\":\"$undefined\",\"notFoundStyles\":\"$undefined\",\"childProp\":{\"current\":[\"$\",\"$L9\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"posts\",\"children\",[\"slug\",\"react-key\",\"d\"],\"children\"],\"loading\":\"$undefined\",\"loadingStyles\":\"$undefined\",\"hasLoading\":false,\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"template\":[\"$\",\"$La\",null,{}],\"templateStyles\":\"$undefined\",\"notFound\":\"$undefined\",\"notFoundStyles\":\"$undefined\",\"childProp\":{\"current\":[\"$Lb\",[\"$\",\"article\",null,{\"className\":\"\",\"children\":[[\"$\",\"div\",null,{\"className\":\"mb-16 text-center\",\"children\":[[\"$\",\"time\",null,{\"dateTime\":\"2025-02-04T00:00:00.000Z\",\"className\":\"mb-1 text-xs text-time\",\"children\":\"February 4, 2025\"}],[\"$\",\"h1\",null,{\"className\":\"text-3xl font-bold\",\"children\":\"React Key\"}]]}],[\"$\",\"div\",null,{\"className\":\"markdownStyles_markdown__IHKMg\",\"children\":[[\"$\",\"h2\",\"h2-0\",{\"children\":\"리액트 Key props에 대해서\"}],\"\\n\",[\"$\",\"p\",\"p-0\",{\"children\":\"리액트에서 배열을 렌더링할 때 key props를 사용해야 합니다. 만약 key props를 사용하지 않으면 브라우저 콘솔창에 경고 메시지가 출력되고, 린트를 사용할 경우에도 경고 혹은 오류 메시지가 보여질 수 있습니다.\"}],\"\\n\",[\"$\",\"pre\",\"pre-0\",{\"children\":[\"$\",\"code\",\"code-0\",{\"className\":\"language-jsx\",\"children\":\"return (\\n  \u003c\u003e\\n    {todos.map((todo) =\u003e (\\n      \u003cTodoItem todo={todo} /\u003e // 🚫\\n    ))}\\n  \u003c/\u003e\\n);\\n\"}]}],\"\\n\",[\"$\",\"h3\",\"h3-0\",{\"children\":\"브라우저 콘솔창 경고 메시지\"}],\"\\n\",[\"$\",\"p\",\"p-1\",{\"children\":[\"$\",\"img\",\"img-0\",{\"src\":\"/images/image.png\",\"alt\":\"브라우저 콘솔창 경고 메시지\"}]}],\"\\n\",[\"$\",\"h3\",\"h3-1\",{\"children\":\"린트 경고 메시지\"}],\"\\n\",[\"$\",\"p\",\"p-2\",{\"children\":[\"$\",\"img\",\"img-0\",{\"src\":\"/images/image-1.png\",\"alt\":\"린트 에러 메시지\"}]}],\"\\n\",[\"$\",\"h2\",\"h2-1\",{\"children\":\"리액트 Key props 사용 이유\"}],\"\\n\",[\"$\",\"p\",\"p-3\",{\"children\":\"그렇다면 리액트 key props 작성을 권장하는 이유가 무엇일까요?\"}],\"\\n\",[\"$\",\"h3\",\"h3-2\",{\"children\":\"최적화\"}],\"\\n\",[\"$\",\"p\",\"p-4\",{\"children\":\"리액트는 Virtual DOM을 통해 렌더링을 최적화하고, Reconciliation(재조정)과정을 통해 변경이 일어난 부분을 파악합니다. key props는 React가 각 요소를 고유하게 식별할 수 있게 해주어, 실제 DOM 업데이트 시 필요한 변경사항만 정확하게 반영할 수 있게 합니다.\"}],\"\\n\",[\"$\",\"h3\",\"h3-3\",{\"children\":\"예시\"}],\"\\n\",[\"$\",\"pre\",\"pre-1\",{\"children\":[\"$\",\"code\",\"code-0\",{\"className\":\"language-jsx\",\"children\":\"const App = () =\u003e {\\n  const [items, setItems] = useState([1, 2, 3]);\\n\\n  return (\\n    \u003cul\u003e\\n      {items.map((item) =\u003e (\\n        \u003cli\u003e{item}\u003c/li\u003e\\n      ))}\\n    \u003c/ul\u003e\\n  );\\n};\\n\"}]}],\"\\n\",[\"$\",\"p\",\"p-5\",{\"children\":\"위 코드를 그림으로 나타내면 아래와 같습니다.\"}],\"\\n\",[\"$\",\"p\",\"p-6\",{\"children\":[\"$\",\"img\",\"img-0\",{\"src\":\"/images/image3.png\",\"alt\":\"리액트 컴포넌트 렌더링\"}]}],\"\\n\",[\"$\",\"p\",\"p-7\",{\"children\":\"위 컴포넌트가 리렌더링 된다면 재조정 과정에서 각각의 li들이 바뀌었는지 확인하는 과정을 거칠 것입니다.\"}],\"\\n\",[\"$\",\"p\",\"p-8\",{\"children\":[\"$\",\"img\",\"img-0\",{\"src\":\"/images/image4.png\",\"alt\":\"리액트 컴포넌트 렌더링\"}]}],\"\\n\",[\"$\",\"p\",\"p-9\",{\"children\":\"변경사항이 없다면 실제 DOM에 반영시키지 않을 것입니다.\"}],\"\\n\",[\"$\",\"p\",\"p-10\",{\"children\":\"만약 items에 4라는 요소가 배열의 마지막에 추가 된다면 어떨까요?\"}],\"\\n\",[\"$\",\"p\",\"p-11\",{\"children\":[\"$\",\"img\",\"img-0\",{\"src\":\"/images/image5.png\",\"alt\":\"리액트 컴포넌트 렌더링\"}]}],\"\\n\",[\"$\",\"p\",\"p-12\",{\"children\":\"새로 추가된 4라는 item은 재조정 과정을 거쳐 실제 DOM에 반영될 것입니다. 그외에 1, 2, 3은 변경사항이 없기 때문에 실제 DOM에 반영되지 않을 것입니다.\"}],\"\\n\",[\"$\",\"p\",\"p-13\",{\"children\":\"하지만 4가 배열의 처음에 추가된다면 어떨까요?\"}],\"\\n\",[\"$\",\"p\",\"p-14\",{\"children\":[\"$\",\"img\",\"img-0\",{\"src\":\"/images/image6.png\",\"alt\":\"리액트 컴포넌트 렌더링\"}]}],\"\\n\",[\"$\",\"p\",\"p-15\",{\"children\":\"위와 같이 재조정 과정에서 두 Virtual Dom을 비교할 때 React는 item3은 새로 추가되었다고 생각하고 그 외는 모두 변경되었다고 생각합니다. 실제로 item 1, 2, 3은 변경사항이 없음에도 실제 DOM에 새롭게 적용되게 됩니다.\"}],\"\\n\",[\"$\",\"p\",\"p-16\",{\"children\":\"지금까지 key props를 사용하지 않았을 때의 문제점을 알아봤습니다. 이제 key props를 사용해서 문제점을 해결해봅시다.\"}],\"\\n\",[\"$\",\"pre\",\"pre-2\",{\"children\":[\"$\",\"code\",\"code-0\",{\"className\":\"language-jsx\",\"children\":\"const App = () =\u003e {\\n  const [items, setItems] = useState([1, 2, 3]);\\n\\n  return (\\n    \u003cul\u003e\\n      {items.map((item) =\u003e (\\n        \u003cli key={item}\u003e{item}\u003c/li\u003e\\n      ))}\\n    \u003c/ul\u003e\\n  );\\n};\\n\"}]}],\"\\n\",[\"$\",\"p\",\"p-17\",{\"children\":\"위와 같이 key props를 사용하면 아래와 같은 효과를 얻을 수 있습니다.\"}],\"\\n\",[\"$\",\"p\",\"p-18\",{\"children\":[\"$\",\"img\",\"img-0\",{\"src\":\"/images/image7.png\",\"alt\":\"리액트 컴포넌트 렌더링\"}]}],\"\\n\",[\"$\",\"p\",\"p-19\",{\"children\":\"고유한 key값을 통해 어떤 값이 추가되었고 어떤 값이 변경이 없는지 정확히 파악할 수 있습니다. 따라서 적은 비용으로 최소한의 변경만 실제 DOM에 반영하고 연산작업을 하여 최적화를 할 수 있습니다.\"}],\"\\n\",[\"$\",\"h2\",\"h2-2\",{\"children\":\"Key props로 배열의 index를 사용하면 안되는 이유\"}],\"\\n\",[\"$\",\"p\",\"p-20\",{\"children\":\"key props를 추가한다면 재조정 과정에서 최적화가 되어 좋을 것입니다. 그렇다면 key로는 아무값이나 넣어도 괜찮을까요? key값은 고유한게 좋으며 바뀌는 값으로 하는 것은 좋지 않습니다. 보통 배열의 index를 key로 사용하는 코드를 볼 수 있는데 리스트 요소가 바뀌지 않는다면 상관없지만 리스트 요소가 바뀐다면 문제가 발생할 수 있습니다.\"}],\"\\n\",[\"$\",\"pre\",\"pre-3\",{\"children\":[\"$\",\"code\",\"code-0\",{\"className\":\"language-jsx\",\"children\":\"const App = () =\u003e {\\n  const [items, setItems] = useState([1, 2, 3]);\\n\\n  return (\\n    \u003cul\u003e\\n      {items.map((item, index) =\u003e (\\n        \u003cli key={index}\u003e{item}\u003c/li\u003e\\n      ))}\\n    \u003c/ul\u003e\\n  );\\n};\\n\"}]}],\"\\n\",[\"$\",\"p\",\"p-21\",{\"children\":\"위와 같이 코드에서 item 4가 items 배열에 맨 앞에 추가된다면 어떨까요?\"}],\"\\n\",[\"$\",\"p\",\"p-22\",{\"children\":[[\"$\",\"img\",\"img-0\",{\"src\":\"/images/image8.png\",\"alt\":\"리액트 컴포넌트 렌더링\"}],\"\\n일단 알아두셔야 할 것은 key이 같으면 인스턴트는 재사용이 된다는 것입니다. 위의 상황에서\\nkey 값이 같은 것들끼리 1:1비교를 합니다. key값이 0인 컴포넌트는 재사용되면서 text가 item4로 변경되고, key 값이 각각 1과 2인 컴포넌트들도 재사용되면서 각각 item1, item2로 텍스트가 변경됩니다. key값이 3인 item은 새롭게 추가됐다고 판단합니다.\"]}],\"\\n\",[\"$\",\"p\",\"p-23\",{\"children\":\"여기서 중요한 문제점이 발생할 수 있습니다. 예를 들어, key값이 0인 컴포넌트가 단순히 텍스트만 렌더링 하는게 아니라 내부 상태(state)를 가지고 있다면, 그 상태는 컴포넌트가 재사용되면서 그대로 유지됩니다. 즉, item1의 상태가 item4에게 그대로 이어지게 되는 것입니다. 이는 사용자 입장에서 예상치 못한 동작을 발생시킬 수 있습니다.\"}],\"\\n\",[\"$\",\"h3\",\"h3-4\",{\"children\":\"예제\"}],\"\\n\",[\"$\",\"pre\",\"pre-4\",{\"children\":[\"$\",\"code\",\"code-0\",{\"className\":\"language-jsx\",\"children\":\"function App() {\\n  const [todos, setTodos] =\\n    useState\u003c{ id: number; text: string }[]\u003e(todoListDefault);\\n\\n  return (\\n    \u003c\u003e\\n      {todos.map((todo, index) =\u003e (\\n        \u003cTodoItem key={index} todo={todo} onSetTodos={setTodos} /\u003e\\n      ))}\\n    \u003c/\u003e\\n  );\\n}\\n\\nfunction TodoItem({\\n  todo,\\n  onSetTodos,\\n}: {\\n  todo: { id: number; text: string };\\n  onSetTodos: Dispatch\u003cSetStateAction\u003c{ id: number; text: string }[]\u003e\u003e;\\n}) {\\n  const [isEditing, setIsEditing] = useState(false);\\n  const [inputText, setInputText] = useState(todo.text);\\n\\n  return (\\n    \u003cdiv\u003e\\n      {isEditing ? (\\n        \u003cinput\\n          type=\\\"text\\\"\\n          value={inputText}\\n          onChange={(e) =\u003e setInputText(e.target.value)}\\n        /\u003e\\n      ) : (\\n        \u003cspan\u003e{todo.text}\u003c/span\u003e\\n      )}\\n      \u003cbutton\\n        onClick={() =\u003e {\\n          setIsEditing(!isEditing);\\n          onSetTodos((prev) =\u003e [...prev, { id: 6, text: inputText }]);\\n        }}\\n      \u003e\\n        {isEditing ? \\\"저장\\\" : \\\"수정\\\"}\\n      \u003c/button\u003e\\n    \u003c/div\u003e\\n  );\\n}\\n\"}]}],\"\\n\",[\"$\",\"p\",\"p-24\",{\"children\":\"위 코드에 대한 결과물은 아래와 같습니다. 맨 앞에 todo6 추가란 버튼을 누르면 todos 배열 맨 앞에 todo6 텍스트를 가진 todo를 추가하도록 했습니다.\"}],\"\\n\",[\"$\",\"p\",\"p-25\",{\"children\":[\"$\",\"img\",\"img-0\",{\"src\":\"/images/image9.png\",\"alt\":\"리액트 컴포넌트 렌더링\"}]}],\"\\n\",[\"$\",\"p\",\"p-26\",{\"children\":\"수정 버튼을 누른 후의 결과물은 아래와 같습니다.\"}],\"\\n\",[\"$\",\"p\",\"p-27\",{\"children\":[\"$\",\"img\",\"img-0\",{\"src\":\"/images/image10.png\",\"alt\":\"리액트 컴포넌트 렌더링\"}]}],\"\\n\",[\"$\",\"p\",\"p-28\",{\"children\":\"만약 위의 상태에서 맨 앞에 todo6 추가란 버튼을 누른다면 어떨까요?\"}],\"\\n\",[\"$\",\"p\",\"p-29\",{\"children\":[\"$\",\"img\",\"img-0\",{\"src\":\"/images/image11.png\",\"alt\":\"리액트 컴포넌트 렌더링\"}]}],\"\\n\",[\"$\",\"p\",\"p-30\",{\"children\":\"위와같이 todo1이 아닌 todo6가 수정 모드가 되었고 안에 텍스트 또한 todo1로 보입니다. 반면 기존 todo1은 수정모드 였다가 수정 모드가 해제 되었습니다. 이러한 문제는 key값을 고유한 값이 아닌 바뀔 수 있는 배열의 index로 사용했기 때문에 나타나는 문제입니다. 이를 해결해주려면 고유의 key값을 사용해야 합니다.\"}],\"\\n\",[\"$\",\"h2\",\"h2-3\",{\"children\":\"마무리\"}],\"\\n\",[\"$\",\"p\",\"p-31\",{\"children\":\"리액트에서 key props를 사용하는 것은 단순히 경고 메시지를 없애기 위한 것이 아닙니다. key props는 리액트의 재조정 과정에서 중요한 역할을 하며, 애플리케이션의 성능 최적화와 올바른 동작을 위해 필수적입니다.\"}],\"\\n\",[\"$\",\"p\",\"p-32\",{\"children\":\"key props 사용 시 주의할 점을 정리하면 다음과 같습니다:\"}],\"\\n\",[\"$\",\"ol\",\"ol-0\",{\"children\":[\"\\n\",[\"$\",\"li\",\"li-0\",{\"children\":\"배열을 렌더링할 때는 반드시 고유한 key props를 사용해야 합니다.\"}],\"\\n\",[\"$\",\"li\",\"li-1\",{\"children\":\"key값으로는 변경되지 않는 고유한 값(ID 등)을 사용해야 합니다.\"}],\"\\n\",[\"$\",\"li\",\"li-2\",{\"children\":\"배열의 index를 key로 사용하면 예상치 못한 버그가 발생할 수 있으므로 피해야 합니다.\"}],\"\\n\"]}]]}]]}],null],\"segment\":\"__PAGE__?{\\\"slug\\\":\\\"react-key\\\"}\"},\"styles\":[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/ee01f9582af6f7e6.css\",\"precedence\":\"next\",\"crossOrigin\":\"\"}]]}],\"segment\":[\"slug\",\"react-key\",\"d\"]},\"styles\":[]}],\"segment\":\"posts\"},\"styles\":[]}]}]}]}]}],null]}]]\n"])</script><script>self.__next_f.push([1,"6:[[\"$\",\"meta\",\"0\",{\"charSet\":\"utf-8\"}],[\"$\",\"title\",\"1\",{\"children\":\"React Key\"}],[\"$\",\"meta\",\"2\",{\"name\":\"description\",\"content\":\"개발 및 일상 기록 개인 블로그\"}],[\"$\",\"meta\",\"3\",{\"name\":\"viewport\",\"content\":\"width=device-width, initial-scale=1\"}],[\"$\",\"meta\",\"4\",{\"name\":\"next-size-adjust\"}]]\nb:null\n"])</script></body></html>