(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[931],{7523:function(n,e,t){Promise.resolve().then(t.bind(t,361))},361:function(n,e,t){"use strict";t.r(e),t.d(e,{default:function(){return Home}});var o=t(7437),s=t(9585);t(7561);var i=JSON.parse('[{"title":"React Key","date":"2025-02-04T00:00:00.000Z","category":"React","description":"React에서 배열 렌더링 시 key props를 사용해야 하는 이유","body":{"raw":"\\n## 리액트 Key props에 대해서\\n\\n리액트에서 배열을 렌더링할 때 key props를 사용해야 합니다. 만약 key props를 사용하지 않으면 브라우저 콘솔창에 경고 메시지가 출력되고, 린트를 사용할 경우에도 경고 혹은 오류 메시지가 보여질 수 있습니다.\\n\\n```jsx\\nreturn (\\n  <>\\n    {todos.map((todo) => (\\n      <TodoItem todo={todo} /> // \uD83D\uDEAB\\n    ))}\\n  </>\\n);\\n```\\n\\n### 브라우저 콘솔창 경고 메시지\\n\\n![브라우저 콘솔창 경고 메시지](/images/image.png)\\n\\n### 린트 경고 메시지\\n\\n![린트 에러 메시지](/images/image-1.png)\\n\\n## 리액트 Key props 사용 이유\\n\\n그렇다면 리액트 key props 작성을 권장하는 이유가 무엇일까요?\\n\\n### 최적화\\n\\n리액트는 Virtual DOM을 통해 렌더링을 최적화하고, Reconciliation(재조정)과정을 통해 변경이 일어난 부분을 파악합니다. key props는 React가 각 요소를 고유하게 식별할 수 있게 해주어, 실제 DOM 업데이트 시 필요한 변경사항만 정확하게 반영할 수 있게 합니다.\\n\\n### 예시\\n\\n```jsx\\nconst App = () => {\\n  const [items, setItems] = useState([1, 2, 3]);\\n\\n  return (\\n    <ul>\\n      {items.map((item) => (\\n        <li>{item}</li>\\n      ))}\\n    </ul>\\n  );\\n};\\n```\\n\\n위 코드를 그림으로 나타내면 아래와 같습니다.\\n\\n![리액트 컴포넌트 렌더링](/images/image3.png)\\n\\n위 컴포넌트가 리렌더링 된다면 재조정 과정에서 각각의 li들이 바뀌었는지 확인하는 과정을 거칠 것입니다.\\n\\n![리액트 컴포넌트 렌더링](/images/image4.png)\\n\\n변경사항이 없다면 실제 DOM에 반영시키지 않을 것입니다.\\n\\n만약 items에 4라는 요소가 배열의 마지막에 추가 된다면 어떨까요?\\n\\n![리액트 컴포넌트 렌더링](/images/image5.png)\\n\\n새로 추가된 4라는 item은 재조정 과정을 거쳐 실제 DOM에 반영될 것입니다. 그외에 1, 2, 3은 변경사항이 없기 때문에 실제 DOM에 반영되지 않을 것입니다.\\n\\n하지만 4가 배열의 처음에 추가된다면 어떨까요?\\n\\n![리액트 컴포넌트 렌더링](/images/image6.png)\\n\\n위와 같이 재조정 과정에서 두 Virtual Dom을 비교할 때 React는 item3은 새로 추가되었다고 생각하고 그 외는 모두 변경되었다고 생각합니다. 실제로 item 1, 2, 3은 변경사항이 없음에도 실제 DOM에 새롭게 적용되게 됩니다.\\n\\n지금까지 key props를 사용하지 않았을 때의 문제점을 알아봤습니다. 이제 key props를 사용해서 문제점을 해결해봅시다.\\n\\n```jsx\\nconst App = () => {\\n  const [items, setItems] = useState([1, 2, 3]);\\n\\n  return (\\n    <ul>\\n      {items.map((item) => (\\n        <li key={item}>{item}</li>\\n      ))}\\n    </ul>\\n  );\\n};\\n```\\n\\n위와 같이 key props를 사용하면 아래와 같은 효과를 얻을 수 있습니다.\\n\\n![리액트 컴포넌트 렌더링](/images/image7.png)\\n\\n고유한 key값을 통해 어떤 값이 추가되었고 어떤 값이 변경이 없는지 정확히 파악할 수 있습니다. 따라서 적은 비용으로 최소한의 변경만 실제 DOM에 반영하고 연산작업을 하여 최적화를 할 수 있습니다.\\n\\n## Key props로 배열의 index를 사용하면 안되는 이유\\n\\nkey props를 추가한다면 재조정 과정에서 최적화가 되어 좋을 것입니다. 그렇다면 key로는 아무값이나 넣어도 괜찮을까요? key값은 고유한게 좋으며 바뀌는 값으로 하는 것은 좋지 않습니다. 보통 배열의 index를 key로 사용하는 코드를 볼 수 있는데 리스트 요소가 바뀌지 않는다면 상관없지만 리스트 요소가 바뀐다면 문제가 발생할 수 있습니다.\\n\\n```jsx\\nconst App = () => {\\n  const [items, setItems] = useState([1, 2, 3]);\\n\\n  return (\\n    <ul>\\n      {items.map((item, index) => (\\n        <li key={index}>{item}</li>\\n      ))}\\n    </ul>\\n  );\\n};\\n```\\n\\n위와 같이 코드에서 item 4가 items 배열에 맨 앞에 추가된다면 어떨까요?\\n\\n![리액트 컴포넌트 렌더링](/images/image8.png)\\n일단 알아두셔야 할 것은 key이 같으면 인스턴트는 재사용이 된다는 것입니다. 위의 상황에서\\nkey 값이 같은 것들끼리 1:1비교를 합니다. key값이 0인 컴포넌트는 재사용되면서 text가 item4로 변경되고, key 값이 각각 1과 2인 컴포넌트들도 재사용되면서 각각 item1, item2로 텍스트가 변경됩니다. key값이 3인 item은 새롭게 추가됐다고 판단합니다.\\n\\n여기서 중요한 문제점이 발생할 수 있습니다. 예를 들어, key값이 0인 컴포넌트가 단순히 텍스트만 렌더링 하는게 아니라 내부 상태(state)를 가지고 있다면, 그 상태는 컴포넌트가 재사용되면서 그대로 유지됩니다. 즉, item1의 상태가 item4에게 그대로 이어지게 되는 것입니다. 이는 사용자 입장에서 예상치 못한 동작을 발생시킬 수 있습니다.\\n\\n### 예제\\n\\n```jsx\\nfunction App() {\\n  const [todos, setTodos] =\\n    useState<{ id: number; text: string }[]>(todoListDefault);\\n\\n  return (\\n    <>\\n      {todos.map((todo, index) => (\\n        <TodoItem key={index} todo={todo} onSetTodos={setTodos} />\\n      ))}\\n    </>\\n  );\\n}\\n\\nfunction TodoItem({\\n  todo,\\n  onSetTodos,\\n}: {\\n  todo: { id: number; text: string };\\n  onSetTodos: Dispatch<SetStateAction<{ id: number; text: string }[]>>;\\n}) {\\n  const [isEditing, setIsEditing] = useState(false);\\n  const [inputText, setInputText] = useState(todo.text);\\n\\n  return (\\n    <div>\\n      {isEditing ? (\\n        <input\\n          type=\\"text\\"\\n          value={inputText}\\n          onChange={(e) => setInputText(e.target.value)}\\n        />\\n      ) : (\\n        <span>{todo.text}</span>\\n      )}\\n      <button\\n        onClick={() => {\\n          setIsEditing(!isEditing);\\n          onSetTodos((prev) => [...prev, { id: 6, text: inputText }]);\\n        }}\\n      >\\n        {isEditing ? \\"저장\\" : \\"수정\\"}\\n      </button>\\n    </div>\\n  );\\n}\\n```\\n\\n위 코드에 대한 결과물은 아래와 같습니다. 맨 앞에 todo6 추가란 버튼을 누르면 todos 배열 맨 앞에 todo6 텍스트를 가진 todo를 추가하도록 했습니다.\\n\\n![리액트 컴포넌트 렌더링](/images/image9.png)\\n\\n수정 버튼을 누른 후의 결과물은 아래와 같습니다.\\n\\n![리액트 컴포넌트 렌더링](/images/image10.png)\\n\\n만약 위의 상태에서 맨 앞에 todo6 추가란 버튼을 누른다면 어떨까요?\\n\\n![리액트 컴포넌트 렌더링](/images/image11.png)\\n\\n위와같이 todo1이 아닌 todo6가 수정 모드가 되었고 안에 텍스트 또한 todo1로 보입니다. 반면 기존 todo1은 수정모드 였다가 수정 모드가 해제 되었습니다. 이러한 문제는 key값을 고유한 값이 아닌 바뀔 수 있는 배열의 index로 사용했기 때문에 나타나는 문제입니다. 이를 해결해주려면 고유의 key값을 사용해야 합니다.\\n\\n## 마무리\\n\\n리액트에서 key props를 사용하는 것은 단순히 경고 메시지를 없애기 위한 것이 아닙니다. key props는 리액트의 재조정 과정에서 중요한 역할을 하며, 애플리케이션의 성능 최적화와 올바른 동작을 위해 필수적입니다.\\n\\nkey props 사용 시 주의할 점을 정리하면 다음과 같습니다:\\n\\n1. 배열을 렌더링할 때는 반드시 고유한 key props를 사용해야 합니다.\\n2. key값으로는 변경되지 않는 고유한 값(ID 등)을 사용해야 합니다.\\n3. 배열의 index를 key로 사용하면 예상치 못한 버그가 발생할 수 있으므로 피해야 합니다.\\n","html":"<h2>리액트 Key props에 대해서</h2>\\n<p>리액트에서 배열을 렌더링할 때 key props를 사용해야 합니다. 만약 key props를 사용하지 않으면 브라우저 콘솔창에 경고 메시지가 출력되고, 린트를 사용할 경우에도 경고 혹은 오류 메시지가 보여질 수 있습니다.</p>\\n<pre><code class=\\"language-jsx\\">return (\\n  &#x3C;>\\n    {todos.map((todo) => (\\n      &#x3C;TodoItem todo={todo} /> // \uD83D\uDEAB\\n    ))}\\n  &#x3C;/>\\n);\\n</code></pre>\\n<h3>브라우저 콘솔창 경고 메시지</h3>\\n<p><img src=\\"/images/image.png\\" alt=\\"브라우저 콘솔창 경고 메시지\\"></p>\\n<h3>린트 경고 메시지</h3>\\n<p><img src=\\"/images/image-1.png\\" alt=\\"린트 에러 메시지\\"></p>\\n<h2>리액트 Key props 사용 이유</h2>\\n<p>그렇다면 리액트 key props 작성을 권장하는 이유가 무엇일까요?</p>\\n<h3>최적화</h3>\\n<p>리액트는 Virtual DOM을 통해 렌더링을 최적화하고, Reconciliation(재조정)과정을 통해 변경이 일어난 부분을 파악합니다. key props는 React가 각 요소를 고유하게 식별할 수 있게 해주어, 실제 DOM 업데이트 시 필요한 변경사항만 정확하게 반영할 수 있게 합니다.</p>\\n<h3>예시</h3>\\n<pre><code class=\\"language-jsx\\">const App = () => {\\n  const [items, setItems] = useState([1, 2, 3]);\\n\\n  return (\\n    &#x3C;ul>\\n      {items.map((item) => (\\n        &#x3C;li>{item}&#x3C;/li>\\n      ))}\\n    &#x3C;/ul>\\n  );\\n};\\n</code></pre>\\n<p>위 코드를 그림으로 나타내면 아래와 같습니다.</p>\\n<p><img src=\\"/images/image3.png\\" alt=\\"리액트 컴포넌트 렌더링\\"></p>\\n<p>위 컴포넌트가 리렌더링 된다면 재조정 과정에서 각각의 li들이 바뀌었는지 확인하는 과정을 거칠 것입니다.</p>\\n<p><img src=\\"/images/image4.png\\" alt=\\"리액트 컴포넌트 렌더링\\"></p>\\n<p>변경사항이 없다면 실제 DOM에 반영시키지 않을 것입니다.</p>\\n<p>만약 items에 4라는 요소가 배열의 마지막에 추가 된다면 어떨까요?</p>\\n<p><img src=\\"/images/image5.png\\" alt=\\"리액트 컴포넌트 렌더링\\"></p>\\n<p>새로 추가된 4라는 item은 재조정 과정을 거쳐 실제 DOM에 반영될 것입니다. 그외에 1, 2, 3은 변경사항이 없기 때문에 실제 DOM에 반영되지 않을 것입니다.</p>\\n<p>하지만 4가 배열의 처음에 추가된다면 어떨까요?</p>\\n<p><img src=\\"/images/image6.png\\" alt=\\"리액트 컴포넌트 렌더링\\"></p>\\n<p>위와 같이 재조정 과정에서 두 Virtual Dom을 비교할 때 React는 item3은 새로 추가되었다고 생각하고 그 외는 모두 변경되었다고 생각합니다. 실제로 item 1, 2, 3은 변경사항이 없음에도 실제 DOM에 새롭게 적용되게 됩니다.</p>\\n<p>지금까지 key props를 사용하지 않았을 때의 문제점을 알아봤습니다. 이제 key props를 사용해서 문제점을 해결해봅시다.</p>\\n<pre><code class=\\"language-jsx\\">const App = () => {\\n  const [items, setItems] = useState([1, 2, 3]);\\n\\n  return (\\n    &#x3C;ul>\\n      {items.map((item) => (\\n        &#x3C;li key={item}>{item}&#x3C;/li>\\n      ))}\\n    &#x3C;/ul>\\n  );\\n};\\n</code></pre>\\n<p>위와 같이 key props를 사용하면 아래와 같은 효과를 얻을 수 있습니다.</p>\\n<p><img src=\\"/images/image7.png\\" alt=\\"리액트 컴포넌트 렌더링\\"></p>\\n<p>고유한 key값을 통해 어떤 값이 추가되었고 어떤 값이 변경이 없는지 정확히 파악할 수 있습니다. 따라서 적은 비용으로 최소한의 변경만 실제 DOM에 반영하고 연산작업을 하여 최적화를 할 수 있습니다.</p>\\n<h2>Key props로 배열의 index를 사용하면 안되는 이유</h2>\\n<p>key props를 추가한다면 재조정 과정에서 최적화가 되어 좋을 것입니다. 그렇다면 key로는 아무값이나 넣어도 괜찮을까요? key값은 고유한게 좋으며 바뀌는 값으로 하는 것은 좋지 않습니다. 보통 배열의 index를 key로 사용하는 코드를 볼 수 있는데 리스트 요소가 바뀌지 않는다면 상관없지만 리스트 요소가 바뀐다면 문제가 발생할 수 있습니다.</p>\\n<pre><code class=\\"language-jsx\\">const App = () => {\\n  const [items, setItems] = useState([1, 2, 3]);\\n\\n  return (\\n    &#x3C;ul>\\n      {items.map((item, index) => (\\n        &#x3C;li key={index}>{item}&#x3C;/li>\\n      ))}\\n    &#x3C;/ul>\\n  );\\n};\\n</code></pre>\\n<p>위와 같이 코드에서 item 4가 items 배열에 맨 앞에 추가된다면 어떨까요?</p>\\n<p><img src=\\"/images/image8.png\\" alt=\\"리액트 컴포넌트 렌더링\\">\\n일단 알아두셔야 할 것은 key이 같으면 인스턴트는 재사용이 된다는 것입니다. 위의 상황에서\\nkey 값이 같은 것들끼리 1:1비교를 합니다. key값이 0인 컴포넌트는 재사용되면서 text가 item4로 변경되고, key 값이 각각 1과 2인 컴포넌트들도 재사용되면서 각각 item1, item2로 텍스트가 변경됩니다. key값이 3인 item은 새롭게 추가됐다고 판단합니다.</p>\\n<p>여기서 중요한 문제점이 발생할 수 있습니다. 예를 들어, key값이 0인 컴포넌트가 단순히 텍스트만 렌더링 하는게 아니라 내부 상태(state)를 가지고 있다면, 그 상태는 컴포넌트가 재사용되면서 그대로 유지됩니다. 즉, item1의 상태가 item4에게 그대로 이어지게 되는 것입니다. 이는 사용자 입장에서 예상치 못한 동작을 발생시킬 수 있습니다.</p>\\n<h3>예제</h3>\\n<pre><code class=\\"language-jsx\\">function App() {\\n  const [todos, setTodos] =\\n    useState&#x3C;{ id: number; text: string }[]>(todoListDefault);\\n\\n  return (\\n    &#x3C;>\\n      {todos.map((todo, index) => (\\n        &#x3C;TodoItem key={index} todo={todo} onSetTodos={setTodos} />\\n      ))}\\n    &#x3C;/>\\n  );\\n}\\n\\nfunction TodoItem({\\n  todo,\\n  onSetTodos,\\n}: {\\n  todo: { id: number; text: string };\\n  onSetTodos: Dispatch&#x3C;SetStateAction&#x3C;{ id: number; text: string }[]>>;\\n}) {\\n  const [isEditing, setIsEditing] = useState(false);\\n  const [inputText, setInputText] = useState(todo.text);\\n\\n  return (\\n    &#x3C;div>\\n      {isEditing ? (\\n        &#x3C;input\\n          type=\\"text\\"\\n          value={inputText}\\n          onChange={(e) => setInputText(e.target.value)}\\n        />\\n      ) : (\\n        &#x3C;span>{todo.text}&#x3C;/span>\\n      )}\\n      &#x3C;button\\n        onClick={() => {\\n          setIsEditing(!isEditing);\\n          onSetTodos((prev) => [...prev, { id: 6, text: inputText }]);\\n        }}\\n      >\\n        {isEditing ? \\"저장\\" : \\"수정\\"}\\n      &#x3C;/button>\\n    &#x3C;/div>\\n  );\\n}\\n</code></pre>\\n<p>위 코드에 대한 결과물은 아래와 같습니다. 맨 앞에 todo6 추가란 버튼을 누르면 todos 배열 맨 앞에 todo6 텍스트를 가진 todo를 추가하도록 했습니다.</p>\\n<p><img src=\\"/images/image9.png\\" alt=\\"리액트 컴포넌트 렌더링\\"></p>\\n<p>수정 버튼을 누른 후의 결과물은 아래와 같습니다.</p>\\n<p><img src=\\"/images/image10.png\\" alt=\\"리액트 컴포넌트 렌더링\\"></p>\\n<p>만약 위의 상태에서 맨 앞에 todo6 추가란 버튼을 누른다면 어떨까요?</p>\\n<p><img src=\\"/images/image11.png\\" alt=\\"리액트 컴포넌트 렌더링\\"></p>\\n<p>위와같이 todo1이 아닌 todo6가 수정 모드가 되었고 안에 텍스트 또한 todo1로 보입니다. 반면 기존 todo1은 수정모드 였다가 수정 모드가 해제 되었습니다. 이러한 문제는 key값을 고유한 값이 아닌 바뀔 수 있는 배열의 index로 사용했기 때문에 나타나는 문제입니다. 이를 해결해주려면 고유의 key값을 사용해야 합니다.</p>\\n<h2>마무리</h2>\\n<p>리액트에서 key props를 사용하는 것은 단순히 경고 메시지를 없애기 위한 것이 아닙니다. key props는 리액트의 재조정 과정에서 중요한 역할을 하며, 애플리케이션의 성능 최적화와 올바른 동작을 위해 필수적입니다.</p>\\n<p>key props 사용 시 주의할 점을 정리하면 다음과 같습니다:</p>\\n<ol>\\n<li>배열을 렌더링할 때는 반드시 고유한 key props를 사용해야 합니다.</li>\\n<li>key값으로는 변경되지 않는 고유한 값(ID 등)을 사용해야 합니다.</li>\\n<li>배열의 index를 key로 사용하면 예상치 못한 버그가 발생할 수 있으므로 피해야 합니다.</li>\\n</ol>"},"_id":"react-key.md","_raw":{"sourceFilePath":"react-key.md","sourceFileName":"react-key.md","sourceFileDir":".","contentType":"markdown","flattenedPath":"react-key"},"type":"Post","url":"/post/react-key"},{"title":"React Rendering","date":"2025-02-01T00:00:00.000Z","category":"React","description":"React Rendering 이해하기","body":{"raw":"\\n> 이 글은 모던 리액트 딥다이브라는 책을 통해 리액트 렌더링 과정에 대해 얻은 지식을 내가 다시볼때 이해하기 쉽도록 정리한 글이다. 본 글은 지속적으로 개선점을 찾아 수정할 예정이다.\\n\\n## 리액트에서 렌더링이란\\n\\n리액트에서의 렌더링이란 리액트 애플리케이션 트리 안에 있는 모든 컴포넌트들이 현재 자신들이 가지고 있는 props와 state의 값을 기반으로 어떻게 UI를 구성하고 이를 바탕으로 어떤 DOM 결과를 브라우저에 제공할 것인지 계산하는 일련의 과정을 의미한다. 만약 컴포넌트가 props와 state와 같은 상태값을 가지고 있지 않다면 오직 해당 컴포넌트가 반환하는 JSX 값에 기반해 렌더링이 일어나게 된다.\\n\\n## 리액트 랜더링 종류\\n\\n### 최초 렌더링\\n\\n사용자가 처음 서비스에 진입 하였을때 브라우저가 렌더링할 결과물이 필요하다. 리액트는 브라우저에 이 정보를 제공하기 위해 최초 렌더링을 수행한다.\\n\\n### 리렌더링\\n\\n리렌더링은 처음 서비스에 진입하여 최초 렌더링이 발생한 이후로 발생하는 모든 렌더링을 의미한다.\\n\\n리렌더링의 원인으로 아래의 시나리오들이 있다.\\n\\n1. useState()의 setter가 실행될 때\\n2. useReducer()의 dispatch가 실행될 때\\n3. key props가 변경될 때\\n4. props가 변경될 때\\n5. 부모 컴포넌트가 리렌더링 될 때\\n\\n위 시나리오에 해당하지 않을 경우, 리렌더링이 발생하지 않는다. key props가 리렌더링에 영향을 주는지 몰랐던 분들도 있을 것이다. 키값이 렌더링에 영향을 줌을 확인하려면 아래 자료를 참고하면 된다.\\n\\n[React 컴포넌트의 key는 렌더링에 영향을 준다](https://velog.io/@js43o/React-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8%EC%9D%98-key%EB%8A%94-%EB%A0%8C%EB%8D%94%EB%A7%81%EC%97%90-%EC%98%81%ED%96%A5%EC%9D%84-%EC%A4%80%EB%8B%A4)\\n\\n## 리액트 리렌더링 과정\\n\\n리렌더링 프로세스가 시작되면 리액트는 컴포넌트의 루트에서부터 차근차근 아래쪽으로 내려가면서 업데이트가 필요하다고 지정돼 있는\\n컴포넌트를 발견하면 함수 컴포넌트의 경우 FunctionComponent() 그 자체를 호출한 뒤에, 그 결과물을 저장한다.\\n\\n```jsx\\nfunction FunctionComponent() {\\n  return <div>Hello, World!</div>;\\n}\\n```\\n\\n위 jsx 문법은 아래와 같이 React.createElement를 호출해서 변환된다.\\n\\n```js\\nfunction FunctionComponent() {\\n  return React.createElement(\\"div\\", null, \\"Hello, World!\\");\\n}\\n```\\n\\n결과물은 아래와 같다.\\n\\n```js\\n{\\n  type: \\"div\\",\\n  props: {\\n    children: \\"Hello, World!\\",\\n  },\\n}\\n```\\n\\n리렌더링은 이런 과정을 거쳐 각 컴포넌트의 렌더링 결과물을 수집하고, 리액트의 새로운 트리인 가상 DOM과 비교해 실제 DOM에 반영하기 위한 모든 변경 사항을 차례차례 수집한다. 이러한 과정을 Reconciliation이라고 한다. 이러한 재조정 과정을 마치면 모든 변경 사항을 하나의 동기 시퀀스로 DOM에 적용해 변경된 결과물이 보이게 된다. 이 과정들을 두 단계로 나눠 각각 렌더 단계, 커밋 단계로 구분한다.\\n\\n### 렌더 단계\\n\\n렌더 단계는 컴포넌트를 렌더링하고 변경 사항을 계산하는 모든 작업을 말한다. 렌더링 과정에서 컴포넌트를 실행해 그 결과와 이전 가상 DOM을 비교하는 과정을 거쳐 변경이 필요한 컴포넌트를 체크하는 단계다. 비교하는 것은 크게 세 가지로, type, props, key다. 세 가지 중 하나라도 변경된 것이 있으면 변경이 필요한 컴포넌트로 체크해 둔다.\\n\\n### 커밋 단계\\n\\n커밋 단계는 렌더 단계의 변경 사항을 실제 DOM에 적용해 사용자에게 보여주는 과정을 말한다. 이 단계가 끝나야 비로소 브라우저 렌더링이 발생한다.\\n\\n리액트의 렌더링이 일어난다고 해서 무조건 DOM 업데이트가 일어나는 것은 아니다. 렌더링을 수행했으나 커밋 단계까지 갈 필요가 없다면, 변경 사항을 계산했는데 변경이 없다면 커밋 단계는 생략될 수 있다.\\n\\n## 이러한 렌더링 프로세스의 이점\\n\\n리액트의 이러한 렌더링 프로세스는 브라우저 렌더링 성능을 최적화하는 데 큰 도움을 줍니다.\\n\\n### 가상 DOM을 통한 효율적인 업데이트\\n\\n실제 DOM을 직접 조작하는 것은 비용이 많이 드는 작업이다. 브라우저는 DOM이 변경될 때마다 레이아웃을 계산하고, 페인팅을 다시 해야 하기 때문이다. 리액트의 가상 DOM은 이러한 문제를 해결하기 위한 중간 계층 역할을 한다.\\n\\n**일괄 처리(Batching)**: 리액트는 여러 변경 사항을 하나의 가상 DOM에서 모두 처리한 후, 최종적으로 실제 DOM에 한 번에 적용한다. 이를 통해 불필요한 중복 렌더링을 방지할 수 있다.\\n\\n**효율적인 DOM 업데이트**: 여러 변경 사항을 하나의 가상 DOM에서 모두 처리한 이후, 실제 DOM에 반영해야 하는데 아예 전체 다 반영하는 것은 당연히 비효율 적이기에 Reconciliation(재조정)과정을 통해 변경된 부분만을 정확하게 파악하고, 필요한 부분만 실제 DOM에 적용한다.\\n\\n## 참고\\n\\n모던 리액트 딥다이브 (위키북스 / 김용찬 지음)\\n","html":"<blockquote>\\n<p>이 글은 모던 리액트 딥다이브라는 책을 통해 리액트 렌더링 과정에 대해 얻은 지식을 내가 다시볼때 이해하기 쉽도록 정리한 글이다. 본 글은 지속적으로 개선점을 찾아 수정할 예정이다.</p>\\n</blockquote>\\n<h2>리액트에서 렌더링이란</h2>\\n<p>리액트에서의 렌더링이란 리액트 애플리케이션 트리 안에 있는 모든 컴포넌트들이 현재 자신들이 가지고 있는 props와 state의 값을 기반으로 어떻게 UI를 구성하고 이를 바탕으로 어떤 DOM 결과를 브라우저에 제공할 것인지 계산하는 일련의 과정을 의미한다. 만약 컴포넌트가 props와 state와 같은 상태값을 가지고 있지 않다면 오직 해당 컴포넌트가 반환하는 JSX 값에 기반해 렌더링이 일어나게 된다.</p>\\n<h2>리액트 랜더링 종류</h2>\\n<h3>최초 렌더링</h3>\\n<p>사용자가 처음 서비스에 진입 하였을때 브라우저가 렌더링할 결과물이 필요하다. 리액트는 브라우저에 이 정보를 제공하기 위해 최초 렌더링을 수행한다.</p>\\n<h3>리렌더링</h3>\\n<p>리렌더링은 처음 서비스에 진입하여 최초 렌더링이 발생한 이후로 발생하는 모든 렌더링을 의미한다.</p>\\n<p>리렌더링의 원인으로 아래의 시나리오들이 있다.</p>\\n<ol>\\n<li>useState()의 setter가 실행될 때</li>\\n<li>useReducer()의 dispatch가 실행될 때</li>\\n<li>key props가 변경될 때</li>\\n<li>props가 변경될 때</li>\\n<li>부모 컴포넌트가 리렌더링 될 때</li>\\n</ol>\\n<p>위 시나리오에 해당하지 않을 경우, 리렌더링이 발생하지 않는다. key props가 리렌더링에 영향을 주는지 몰랐던 분들도 있을 것이다. 키값이 렌더링에 영향을 줌을 확인하려면 아래 자료를 참고하면 된다.</p>\\n<p><a href=\\"https://velog.io/@js43o/React-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8%EC%9D%98-key%EB%8A%94-%EB%A0%8C%EB%8D%94%EB%A7%81%EC%97%90-%EC%98%81%ED%96%A5%EC%9D%84-%EC%A4%80%EB%8B%A4\\">React 컴포넌트의 key는 렌더링에 영향을 준다</a></p>\\n<h2>리액트 리렌더링 과정</h2>\\n<p>리렌더링 프로세스가 시작되면 리액트는 컴포넌트의 루트에서부터 차근차근 아래쪽으로 내려가면서 업데이트가 필요하다고 지정돼 있는\\n컴포넌트를 발견하면 함수 컴포넌트의 경우 FunctionComponent() 그 자체를 호출한 뒤에, 그 결과물을 저장한다.</p>\\n<pre><code class=\\"language-jsx\\">function FunctionComponent() {\\n  return &#x3C;div>Hello, World!&#x3C;/div>;\\n}\\n</code></pre>\\n<p>위 jsx 문법은 아래와 같이 React.createElement를 호출해서 변환된다.</p>\\n<pre><code class=\\"language-js\\">function FunctionComponent() {\\n  return React.createElement(\\"div\\", null, \\"Hello, World!\\");\\n}\\n</code></pre>\\n<p>결과물은 아래와 같다.</p>\\n<pre><code class=\\"language-js\\">{\\n  type: \\"div\\",\\n  props: {\\n    children: \\"Hello, World!\\",\\n  },\\n}\\n</code></pre>\\n<p>리렌더링은 이런 과정을 거쳐 각 컴포넌트의 렌더링 결과물을 수집하고, 리액트의 새로운 트리인 가상 DOM과 비교해 실제 DOM에 반영하기 위한 모든 변경 사항을 차례차례 수집한다. 이러한 과정을 Reconciliation이라고 한다. 이러한 재조정 과정을 마치면 모든 변경 사항을 하나의 동기 시퀀스로 DOM에 적용해 변경된 결과물이 보이게 된다. 이 과정들을 두 단계로 나눠 각각 렌더 단계, 커밋 단계로 구분한다.</p>\\n<h3>렌더 단계</h3>\\n<p>렌더 단계는 컴포넌트를 렌더링하고 변경 사항을 계산하는 모든 작업을 말한다. 렌더링 과정에서 컴포넌트를 실행해 그 결과와 이전 가상 DOM을 비교하는 과정을 거쳐 변경이 필요한 컴포넌트를 체크하는 단계다. 비교하는 것은 크게 세 가지로, type, props, key다. 세 가지 중 하나라도 변경된 것이 있으면 변경이 필요한 컴포넌트로 체크해 둔다.</p>\\n<h3>커밋 단계</h3>\\n<p>커밋 단계는 렌더 단계의 변경 사항을 실제 DOM에 적용해 사용자에게 보여주는 과정을 말한다. 이 단계가 끝나야 비로소 브라우저 렌더링이 발생한다.</p>\\n<p>리액트의 렌더링이 일어난다고 해서 무조건 DOM 업데이트가 일어나는 것은 아니다. 렌더링을 수행했으나 커밋 단계까지 갈 필요가 없다면, 변경 사항을 계산했는데 변경이 없다면 커밋 단계는 생략될 수 있다.</p>\\n<h2>이러한 렌더링 프로세스의 이점</h2>\\n<p>리액트의 이러한 렌더링 프로세스는 브라우저 렌더링 성능을 최적화하는 데 큰 도움을 줍니다.</p>\\n<h3>가상 DOM을 통한 효율적인 업데이트</h3>\\n<p>실제 DOM을 직접 조작하는 것은 비용이 많이 드는 작업이다. 브라우저는 DOM이 변경될 때마다 레이아웃을 계산하고, 페인팅을 다시 해야 하기 때문이다. 리액트의 가상 DOM은 이러한 문제를 해결하기 위한 중간 계층 역할을 한다.</p>\\n<p><strong>일괄 처리(Batching)</strong>: 리액트는 여러 변경 사항을 하나의 가상 DOM에서 모두 처리한 후, 최종적으로 실제 DOM에 한 번에 적용한다. 이를 통해 불필요한 중복 렌더링을 방지할 수 있다.</p>\\n<p><strong>효율적인 DOM 업데이트</strong>: 여러 변경 사항을 하나의 가상 DOM에서 모두 처리한 이후, 실제 DOM에 반영해야 하는데 아예 전체 다 반영하는 것은 당연히 비효율 적이기에 Reconciliation(재조정)과정을 통해 변경된 부분만을 정확하게 파악하고, 필요한 부분만 실제 DOM에 적용한다.</p>\\n<h2>참고</h2>\\n<p>모던 리액트 딥다이브 (위키북스 / 김용찬 지음)</p>"},"_id":"react-rendering.md","_raw":{"sourceFilePath":"react-rendering.md","sourceFileName":"react-rendering.md","sourceFileDir":".","contentType":"markdown","flattenedPath":"react-rendering"},"type":"Post","url":"/post/react-rendering"}]');[...i];var r=t(9233),a=t(2265),p=t(2418),d=t(5080),l=t(3920),c=t(550);let m=(0,d.j)("inline-flex items-center justify-center gap-2 whitespace-nowrap rounded-md text-sm font-medium transition-colors focus-visible:outline-none focus-visible:ring-1 focus-visible:ring-ring disabled:pointer-events-none disabled:opacity-50 [&_svg]:pointer-events-none [&_svg]:size-4 [&_svg]:shrink-0",{variants:{variant:{default:"bg-primary text-primary-foreground shadow hover:bg-primary/90",destructive:"bg-destructive text-destructive-foreground shadow-sm hover:bg-destructive/90",outline:"border border-input bg-background shadow-sm hover:bg-accent hover:text-accent-foreground",secondary:"bg-secondary text-secondary-foreground shadow-sm hover:bg-secondary/80",ghost:"hover:bg-accent hover:text-accent-foreground",link:"text-primary underline-offset-4 hover:underline"},size:{default:"h-9 px-4 py-2",sm:"h-8 rounded-md px-3 text-xs",lg:"h-10 rounded-md px-8",icon:"h-9 w-9"}},defaultVariants:{variant:"default",size:"default"}}),u=a.forwardRef((n,e)=>{let{className:t,variant:s,size:i,asChild:r=!1,...a}=n,d=r?p.g7:"button";return(0,o.jsx)(d,{className:function(){for(var n=arguments.length,e=Array(n),t=0;t<n;t++)e[t]=arguments[t];return(0,c.m6)((0,l.W)(e))}(m({variant:s,size:i,className:t})),ref:e,...a})});u.displayName="Button";var g=t(4135),x=t(3088);function DarkModeToggleButton(){let{theme:n,setTheme:e}=(0,r.F)();return(0,o.jsxs)(u,{className:"rounded-full",variant:"outline",size:"icon",onClick:()=>{"dark"===n?e("light"):e("dark")},children:[(0,o.jsx)(g.Z,{className:"h-[1.2rem] w-[1.2rem] rotate-0 scale-100 transition-all dark:-rotate-90 dark:scale-0 text-[#228be6]"}),(0,o.jsx)(x.Z,{className:"absolute h-[1.2rem] w-[1.2rem] rotate-90 scale-0 transition-all dark:rotate-0 dark:scale-100 text-yellow-400"}),(0,o.jsx)("span",{className:"sr-only",children:"Toggle theme"})]})}function CategoryFilter(n){let{categories:e,selectedCategory:t,onChange:s}=n;return(0,o.jsxs)("div",{className:"flex gap-2 mb-8",children:[(0,o.jsx)(CategoryButton,{category:"All",selectedCategory:t,onChange:s}),e.map(n=>(0,o.jsx)(CategoryButton,{category:n,selectedCategory:t,onChange:s},n))]})}function CategoryButton(n){let{category:e,selectedCategory:t,onChange:s}=n;return(0,o.jsx)("button",{onClick:()=>s(e),className:"px-3 py-1 rounded-full text-md ".concat(t===e?"bg-[#228be6] text-primary-foreground":"bg-secondary"),children:e})}var y=t(1396),h=t.n(y);function PostCard(n){let{post:e}=n;return(0,o.jsx)(h(),{href:e.url,children:(0,o.jsxs)("article",{className:"p-4 rounded-lg hover:shadow-lg transition-shadow duration-300",children:[(0,o.jsx)("h2",{className:"text-xl font-semibold",children:e.title}),(0,o.jsxs)("div",{className:"text-sm text-muted-foreground mt-2",children:[(0,o.jsx)("span",{children:new Date(e.date).toLocaleDateString("ko-KR")}),(0,o.jsx)("span",{className:"mx-2",children:"•"}),(0,o.jsx)("span",{children:e.category})]}),(0,o.jsx)("p",{className:"mt-2 text-muted-foreground",children:e.description})]})})}function Home(){let[n,e]=(0,a.useState)("All"),t=(0,a.useMemo)(()=>{let n=new Set(i.map(n=>n.category));return Array.from(n)},[]),r=(0,a.useMemo)(()=>"All"===n?i.sort((n,e)=>(0,s.Z)(new Date(n.date),new Date(e.date))):i.filter(e=>e.category===n).sort((n,e)=>(0,s.Z)(new Date(n.date),new Date(e.date))),[n]);return(0,o.jsxs)("div",{className:"",children:[(0,o.jsxs)("header",{className:"flex justify-between items-center mb-8",children:[(0,o.jsx)("h1",{className:"text-2xl font-black",children:"PearlDev \uD83E\uDDCB"}),(0,o.jsx)(DarkModeToggleButton,{})]}),(0,o.jsx)(CategoryFilter,{categories:t,selectedCategory:n,onChange:e}),(0,o.jsx)("div",{className:"grid gap-4",children:r.map(n=>(0,o.jsx)(PostCard,{post:n},n._id))})]})}}},function(n){n.O(0,[568,971,472,744],function(){return n(n.s=7523)}),_N_E=n.O()}]);